---
layout: post
title: "기말고사 정리"
comments: true
description: ""
keywords: ""
---


# 기말고사 정리

<div class='divider'></div>



## 15장 Broadcast Receiver(1)

 브로드캐스트 리시버
     - 용도 : 설치된 앱이나 실행중인 앱이 반드시 알아야할 중요한 정보를 받기위해 / 왜냐면 예상치 못한 상황 전에 중요한 정보를 미리 저장해야함

브로드캐스트의 기본동작
     안드 시스템에서 앱들이 알아야 할 상황이 발생하면 '방송'해주고 앱들은 '수신기'를 통해 상황을 감지 할 수 있다.
     수신기가 브로드캐스트 리시버 컴포넌트다.
     시스템 뿐만 아니라 각종 앱들이 원하는 상황을 방송 가능
     브로드캐스트리시버를 미리 달아두고 원하는 방송을 들을 수 있음.

방송하는 액티비티와 기존 액티비티의 등록 방법은 동일함.

액티비티 실행과 같이 방송도 인텐트를 이용함

방송의 이름은 액션명으로 지정됨
     액션명은 패키지명으로 시작하고 개발자가 명명가능

정적리시버는 한번 등록하면 해제 불가
동적리시버는 등록과 해제가 자유로움

리시버 클래스
     브로드캐스트리시버 클래스를 상속받는다.
     onReceive 함수만 재정의하면 끝. 즉 원하는 방송을 받으면 onReceive 함수가 호출됨.

정적 리시버
     매니페스트에 설정해두면 자동으로 리시버를 등록해줌

동적 리시버
     매니페스트를 통해 설정하지 않는다.
     동적이란 런타임시에 등록한다는 의미.
     동적 리시버는 다른 컴포넌트 내에서 동적으로 정의한다.

동적 리시버 등 방법
     매니페스트에 정적으로 등록하는 절차와 유사
     차이점 : 시스템이 자동으로 등록하는 대신 개발자가 등록해야함.
     onCreate {
     IntentFilter intentFilter = new IntentFilter();
     intentFilter.addAction('관심방송의 액션명');

     registerReceiver( mFileDownloadedReceiver, intentFilter ); //개발자가 리시버를 동적으로 등록
}

동적 리시버 해제
액티비티 생명 주기 내에서 unregisterReceiver로 해제 그렇지않으면 메모리누수
     onDestroy {
     unregisterReceiver(mFileDownloadReceiver)
}

동적리시버는 다른 컴포넌트에 귀속되기 때문에 다른 컴포넌트의 생명주기가 끝나면 동작하지 않는다

정/동적 리시버는 방송시작시 전달하는 인텐트 플래그에따라 실행 안될 수 도 있다. 몰래 앱설치되는걸 막아야함

FLAG_EXCLUDE_STOPPED_PACKAGES 인텐트 플래그
     - 한 번이라도 앱이 실행되어야만 정적 리시버가 동작함

     - 정적리시버를 등록했다 해도 정적리시버가 포함된 액티비티가 실행되지 않으면 동작하지 않는다.

FLAG_INCLUDE_STOPPED_PACKAGES 인텐트 플래그
     - EXCLUDE와 반대 / 실행되지 않았던 앱의 정적 리시버라도 방송을 받아서 처리함.
     - 사용을 자제할것 의도하지않은 위험한 앱이 동작해 부하를 줄수 있음!

## Broadcast Breceiver (2)

FLAG_RECEIVER_REGISTERED_ONLY 인텐트 플래그
     - 오직 동적 리시버만 방송을 수신할 수 있는 인텐트 플래그
     - 특정 앱의 정적리시버가 백그라운드에서 몰래 실행되는것을 막기위해 사용!!
intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY ); // 사용예

방송은 리시버만 등록하면 받을 수 있기에 부하가 크다.
     - 화면이 꺼지고 켜질때도 시스템은 그 사실을 방송하기에 부하 걸릴 수 있음.
     - 때문에 방송을 보내는 곳을 신중해야함

빈번한 리시버를 막는 방법.
     - FLAG_EXCLUDE_STOPPED_PACKAGES 사용
     - FLAG_RECEIVER_REGISTERED_ONLY 로 동적리시버만 동작하게함.
     - 안드 시스템에서 발송하는 방송은 이 두가지 플래그를 포함하는 경우가 많다.

■ FLAG FLAG_RECEIVER_REPLACE_PENDING 인텐트 플래그
     - 중복해서 동일 액션으로 방송될경우 중복방송을 제거
     - 해당 플래그를 설정했더라도 최소 두번의 방송은 전달 될 수 있다!!
방송큐에 담긴 3/2/1 중에 1은 보내자마자 시작되고
남은 3/2 두개가 방송큐에 남으면 중복제거되어 3이 뒤이어 방송됨

리시버도 메인 스레드에서 처리되기 때문에 제한시간이 존재한다.

포그라운드 방송
     - FLAG_RECEIVER_FOREGROUND 플래그로  처리
     - 빠른 처리를 요하는 방송.
     - 액티비티 매니저는 포그라운드 방송을 우선처리한뒤 백그라운드를 처리함.

포그라운드 방송은 우선순위가 높지만 ANR에 걸리는 시간이 작다. 그만큼 더 빨리 처리해야하기 때문

리시버도 액티비티와 같은 메인 스레드를 사용
     - 리시버가 늦게 동작하면 액티비티도 영향받음

따라서 리시버가 긴 시간이 걸리는 작업을 처리하려면 작업 스레드를 사용하거나 '서비스'를 써야함

방송이 먼저 발생하고, 뒤에 방송을 원하는 앱이 실행된다면, 해당 방송은 앱이 실행되기 전에 삭제된다. 따라서 리시버가 호출되지 않음

리시버 호출 순서와 우선순위

정적리시버 호출 1~5
1시작1끝 2시작2끝~ 5시작5끝

결과 : 정적 리시버는 동시에 처리되지 않는다.
     - 리시버 자체는 메인 스레드에서 돌아가기 때문에 절대 긴 작업을 처리하지 않도록 해야한다.

동적리시버 호출 1~5
1시작~5시작 24531끝

동적 리시버는 액티비티가 종료되면 동작하지 않는다.

중요! 정적 리시버와 달리 모든 리시버가 동시에 실행. 순서대로 실행되는 정적 리시버보다 빠름

동/정적 리시버의 우선순위는 변경가능
     -인텐트 필터의 setPriorty함수를 사용하여 우선순위를 조정
     - 기본 우선순위는 0부터 시작 클수록 우선순위가 높다.

동적리시버는 결국 동시에 실행되기 때문에 우선순위가 큰 의미없다.
sendBroadcast 함수 대신 sendOrderedBroadcast 함수 사용해서 동적리시버를 순서대로 처리 가능

sendOrderedBroadcast의 특별한 기능
     - 특정 리시버가 수신했을때 다른 리시버가 못받도록 중단함
     - 단, sendOrderedBroadcast함수로 전달된 방송에대한 처리만 중단가능
     예 /   abortBroadcast();
             Log.i("superdroid", "==> abortBroadcast ");

방송은 특정 패키지에만 발송할 수도 있다.

화면 켜짐 방송을 수신하기 위해서는 정적리시버는 받을 수없다.
FLAG_RECEIVER_REGISTERED_ONLY 인텐트 플래그 를 사용해야함 즉, 동적리시버를 사용해야함

## 18장 서비스 -1

서비스
     - 4대 컴포넌트중 제일 어렵고 중요

액티비티의 종료와 메인 스레드의 관계
     - 액티비티가 종료된다고 해서 메인스레드가 종료 되는것은 아니다. 메인 스레드는 루퍼 객체의 loop에서 대기중.
     - 강제 종료가 되어야 메인스레드가 종료된다.

액티비티의 생명주기가 다 하면 그 객체 자체도 소멸한다.
     - 유의 ! 메인스레드가 종료되지 않았기 때문에 스레드는 종료하지 않는다.

앱 재실행 시, 실행 중에 메인 스레드는 액티비티 객체를 재생성하고, onCreate 함수도 호출한다.
 > mCountThread의 초기화로 인해, 이전 스레드의 reference를 상실함. 즉, 제어할 수 없다.
  즉, Stop Count 동작도 안됨: mCountThread.interrupt()가 동작 안됨.
 > mCurNum의 초기화로 인해, 이전 count 값을 모두 상실함.

서비스는 다른 컴포넌트에 의존하지않고 백그라운드에서 독립적으로 동작함
각종 컴포넌트에서 서비스를 제어하거나 원하는 정보를 참조가능.

서비스는 프로세스간 메모리를 공유하거나 원하는 함수를 호출할수있는
IPC / RPC를 지원함

2개의 서비스형태 스타디드모드 / 바운드모드를 가짐

스타디드는 동작시켜두는데 목적을 둔 형태의 서비스!!
      - 서비스를 동작시킨 컴포넌트는 서비스를 중단하는것 이외에 제어 불가
     - 동작된 서비스는 알아서 백그라운드에서 작업하고 종료됨.

     - 내/외부 앱과 음악재생 서비스는 서로 독립적
     - 서비스를 동작시킨 컴포넌트가 종료되더라도 서비스는 작업이 끝날때까지 유지됨.

바운드는 외부 라이브러리를 사용하는것과 유사
     - 내/외부 앱과 계싼 서비스의 관계는 서로 의존적
     - 서비스를 요청한 컴포넌트가 종료되면 서비스 연결도 끊어진다.
     - 내/외부 컴포넌트와 연결을 끊는 요청이 없는 이상, 요청작업이 완료되더라도 연결은 유지한다.

음악 재생이 필요하면 스타디드
재생중인 앱의 일시정지는 바운드

서비스 생성시 onCreate -> onStartCommand 순으로 호출 / 종료시 onDestory 호출
     - onCreate : 생성시에만 호출, 초기화 작업  수행
     - onStartCommand : 서비스가 수행할 동작이 구현
     - 동작중
     - onDestroy : 서비스가 종료전 호출, 필요시 자원반환

스타티드 서비스 구현 순서
     - 서비스 클래스 생성
     - 매니페스트에 서비스등록
     - 액티비티에서 서비스 시작 인텐트사용
     - 서비스 실행중 다시 서비스 실행하면 onStartCommand 함수부터 호출됨.
     - stopSErvice 함수 호출하면 종료전에 onDestroy호출됨

잊지 말것! 서비스는 기본적으로 메인 스레드에서 실행됨. 액티비티,리시버,서비스 다

스타티드는 백그라운드에서 오랜 시간이 걸리는 작업을 처리하기 위함.
     - 메인 스레드가아닌 별도의 작업스레드에서 처리하는게 당연함

백그라운드에서 동작중인 서비스는 stopService함수를 통해 강제로 종료가능.

안드는 swap space를 사용하지않아 메모리 제한이 따른다. 그래서 쓰면됨

메모리 부족할때 다른 앱의 프로세스를 죽이고 메모리 확보하면됨 -> LMK

우선 순위를 통한 LMK의 앱 종료 정책
     - 앱 상태에 따라 우선순위를 두고 높은 앱부터 죽임.
     - 우선순위가 높은건 쓸모없는 순위

리눅스 커널 프로세스 종료 정책
     - OOM Killer 동작 시점은 이미 swap space를 포함한 전체메모리가 꽉찼다는걸 의미
     - 유저 / 커널 프로세스를 구분없이 죽임

LMK는 우선순위를 통해 유저 스페이스에 앱을 종료 시킴
LMK로 감당안되는 메모리 부족일때 OOM 킬러가 실행되어 다 죽임

시스템 < 시스템 앱 < 가장앞에 보이는앱 < 뒤에 보이는앱 < 지각되는 서비스앱
대부분 LMK의 정리대상이 아님

< 홈앱 < 뒤에 가려진앱 < 서비스앱 < 죽은앱
정리대상의 확률이 큼

앱의 우선순위
     - Service -> service A , B 로 구분
     - B가 LMK에 의해 종료된 뒤 다시 살아나면 A가됨
     - 이유 A에서 30분동안 살려두려고

액티비티+서비스로 구성된앱에서 액티비티가 제거되면 서비스의 상태가됨

백그라운드에 실행되는 서비스가 LMK에의해 갑자기 종료되는걸 방지하기위해
  > 스타티드 서비스의 onStartCommand 함수 반환값을 START_STICKY로 설정한다.

START_STICKY - LMK에 의해 강종이후 가용 메모리가 확보되면 다시 서비스를 실행시킴. / 중요한앱
START_NOT_SITCKY - 강종 되어도 실행 안시켜줌 / 생존이 중요하지않을때 이용

START_REDELIVER_INTENT - STICKY와 동일하지만 인텐트 정보를 복원해줌 , 다시 실행되면 onStartCommand함수의 인텐트 매개변수를 다시 돌려줌

## 18장 서비스 - 2

+ 인텐트 서비스
     - 스타티드 서비스의 파생클래스
     - 클라이언트가 startService와 인텐트를 전달할때 순차적으로 동작.
     특징
          - 여러개 동시에 전달되더라도 순차적으로 하나씩 처리.

     문제점 (인텐트 서비스를 사용하지 않을 시)
          - 동시에 실행되는 서비스는 동기화 문제를 야기

     장점 (인텐트 서비스를 사용할 시)
     - 따로 스레드를 생성할 필요가 없다. 즉 서비스측에서 ANR걱정 ㄴㄴ
     - 동기화 문제가 자동으로 해결

     활용도가 높음
     - 스타티드 서비스 구현시 인텐트 서비스를 사용하는게 구현하기 간단함.
     - 동기화 / ANR 문제가 발생하지않음

+ 바운드 서비스 - 서비스 연결

onBind 특정 앱에서 서비스를 연결할때 호출
onUnbind 서비스 해제할때 호출됨

앱과 서비스간의 매게체, 즉 인터페이스가 없으면 클라는 아무런 요청할 수없다.

안드에서 통신을 가능하게 하는 매게체를 바인더라 함!

바인더
     - 서비스에 존재하는 인터페이스를 포함.
     - 클라는 바인더를 이용해 서비스의 인터페이스를 호출 가능.

바인더를 만드는건 복잡하다
     - 안드의 인터페이스 정의언어 AIDL을 사용
     - AIDL로 인터페이스를 작성하면 자동으로 바인더를 생성해줌.

'''
mBinder = ICountService.Stub.asInterface(service)
     - 서비스가 onBind함수로 변환한 바인더 객체 획득 방법
'''

BIND_AUTO_CREATE 플래그를 사용하면
onServiceDisconnected함수가 호출되지 않음.

기본적으로 클라이언트의 startService 함수를 통해 서비스가 시작되지 않은 상태에서, bindService 함수를 통해 서비스를 연결할 수 없다.

BIND_AUTO_CREATE 플래그
     - 스타티드 서비스가 실행되지 않은 상태에서 바운드 사용 가능
     - 스타티드와 바운드 서비스의 관계를 끊어주는 유일값.

바운드 서비스의 재실행
     - 클라에 연결된 바운드 서비스는 죽으면 자동으로 다시 연결됨
     - 바운드 서비스의 안정성은 시스템이 보장

onServiceDisconnected함수가 호출되지 않는 이유
     - BIND_AUTO_CREATE가 unbindservcie함수로 바인딩을 끊어도 서비스 사용가능.
     - 이유 : 자동으로 서비스를 재실행해서

서비스의 공개된 인터페이스가 오래걸리는 작업을 수행 가능
     - 문제점 : 그만큼 해당 인터페이스를 사용한 클라는 대기해야됨.
     - 오래동안 대기중인 클라는 ANR발생가능

     - 해결책 : 콜백 인터페이스
     - 콜백 인터페이스는 비동기 방식으로 처리할때 사용

     콜백 예제 다시보기!!

메신저 서비스
     - AIDL파일없이 프로세스간 통신이 가능.
     - 인텐트 서비스와 같이 여러 클라에 요청 순으로 처리하기 때문에 동기화 보장.

     메세지 예제 보기!!

## 18장 서비스 - 3

알림 Notification
     - 백그라운드 서비스 또는 프로세스가 사용자와 통신할 수 있는 수단중 하나

PendingIntent
    - 다른 앱, 시스템 서비스에게 원하는 기능을 요청할때 사용하는 Intent

     - 특이사항 요청한 앱의 실행권한을 다른 앱/시스템서비스에게 넘김

스타티드 서비스 - 두번째 생존방법 : 알림기능
    1. 인텐트 생성하고 설정하기
     - 주로, 액티비티를 띄우기 위해 인텐트에FLAG_ACTIVITY_NEW_TASK 플래그를 지정한다.
     2. 알림 매니저를 생성하고, 등록한다.
     - 객체를 얻기위해 사용 getSystemServer(NOTIFICATION_SERVICE)
예제 보기

시스템은 두가지 동작을 수행함.
     - Notification 객체를 통해 알림과 알림창에 표시.
     - PendingIntent에 포함된 intent를 이용하여 창을 탭했을때 액티비티 실행함.

자각되는 서비스란
    - 사용자가 서비스의 존재를 자각할 수 있는 서비스를 말함.
문제점
     - 알림표시에 메모리가 부족해서 재생 서비스가 죽을 수 있음.
     - 포그라운드 상태가 되어야함.

해결책
     - 포그라운드 상태로 만든다.
      - void startForeground(int id, Notification notification); 함수를 사용해서

- 16장 파일과 데이터베이스

매니저 클래스 사용이유
     -  여러 스레드/프로세스에서 접근하면 동기화문제가 생김
     - 유지보수 / 재사용의 장점이 있음
      - 자원관리리는 매니저 클래스를 꼭 둔다
코드보기!!

공유 프레퍼런스
     - 해쉬맵 클래스를 이용해 데이터를 키와 값 형태로 쉽게 다룸
