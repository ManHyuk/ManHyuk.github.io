---
layout: post
title: "트랜잭션에 대하여"
comments: false
description: ""
keywords: ""
---

이번에 공부하게 된 트랜잭션에 대해 정리를 해본다.

먼저 미래의 나를 믿지 못하기에 미리 트랜잭션이 무엇인지 간단히 정의를 하고 넘어 가기로 하겠다.


### 트랜잭션?
---

트랜잭션(Transaction 이하 트랜잭션)이란, 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻한다.

데이터베이스의 상태를 변화시킨다는 것은 무얼 의미하는 것일까?

간단하게 말해서 아래의 질의어(SQL)를 이용하여 데이터베이스를 접근 하는 것을 의미한다.

SELECT, INSERT, DELETE, UPDATE

착각하지 말아야 할 것은, 작업의 단위는 질의어 한문장이 아니라는 점이다.

작업단위는 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다.

### 트랜잭션 특징
---

트랜잭션의 특징은 크게 4가지로 구분된다.

- Atomicity(원자성): 이체 과정 중에 트랜잭션이 실패하게 되어 예금이 사라지는 경우가 발생해서는 안 되기 때문에 DBMS는 완료되지 않은 트랜잭션의 중간 상태를 데이터베이스에 반영해서는 안 된다. 즉, 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다. atomicity는 쉽게 'all or nothing' 특성으로 설명된다.

- Consistency(일관성): 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다. 즉, 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다. 트랜잭션의 수행을 데이터베이스 상태 간의 전이(transition)로 봤을 때, 트랜잭션 수행 전후의 데이터베이스 상태는 각각 일관성이 보장되는 서로 다른 상태가 된다. 트랜잭션 수행이 보존해야 할 일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들뿐만 아니라, 자금 이체 예에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있다.

- Isolation(독립성): 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 한다. 즉, 한 트랜잭션의 중간 결과가 다른 트랜잭션에게는 숨겨져야 한다는 의미인데, 이러한 isolation 성질이 보장되지 않으면 트랜잭션이 원래 상태로 되돌아갈 수 없게 된다. Isolation 성질을 보장할 수 있는 가장 쉬운 방법은 모든 트랜잭션을 순차적으로 수행하는 것이다. 하지만 병렬적 수행의 장점을 얻기 위해서 DBMS는 병렬적으로 수행하면서도 일렬(serial) 수행과 같은 결과를 보장할 수 있는 방식을 제공하고 있다.

- Durability(지속성): 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다.

> 학교에서 디비 수업을 듣지 못한 나도 들어본 **ACID**


### 분산 데이터베이스 트랜잭션
네트워크로 물린 여러 데이터베이스가 참여 한다.

A의 데이터는 A-a 라는 디비에 있고, B의 데이터는 B-b 라는 디비에 있다면

거래를 하면서 돈이 없어지거나 복사되지 않는 다는 보장을 어떻게 보장 해야할까?

- 해결 방안 1 - XA
  - 커밋할 준비(무결성 확인)와 실제 커밋(디스크에 쓰기)을 분리
  - DB가 여럿일 때에도 고립성을 확보해준다.
- 문제점
  - 장애 상황(서버 다운)에서 원자성을 보장하지 않는다.
  - 느림


- 해결 방안 2 - 직접 만든다 ( 애플리케이션 레벨 분산 트랜잭션 )



로컬 트랜잭션을 여러번 실행해서 분산 트랜잭션을 구현한다.

하지만 물품 거래를 예로 들면 A의 트랜잭션 (물품 제거, 잔액 증가) 과 B의 트랜잭션(잔액 감소, 물품 추가)사이에서

갑자기 B의 디비서버가 꺼진다면 트랜잭션의 무결성을 보장할 수 없게 된다.

이러한 문제점을 보완하기 위해서는 두가지 접근 방법이 있다.
1. 작업하는 동안 다른 동작을 하게 한다
  - 비관적 동기화 ( 락 기반 동기화 )
2. 일단 진행하고, 문제가 생기면 롤백한다
  - 낙관적 동기화 ( 예/ 트랜잭셔널 메모리 )


비관적 동기화의 문제점은 모든 디비 변경에서 락을 잡아야하고

작업하는 동안 다른 동작을 못하게 할 수 없는 현상이 있다 ( 서버 다운 )

낙관적 동기화의 문제점은 애플리케이션 레벨에서 롤백을 구현해야 한다는 점이다.

애플리케이션 레벨에서의 트랜잭션을 구현하기 우ㅟ해서는 두 단계로 나눌 수 있다.

- 퍼스트 로컬 트랜잭션 ( FLT )
  - 실패할 가능성이 있는 것
  - 안전하게 롤백할 수 있어야 한다. (롤백 해야 된다.)
  - 예/ 물품 제거, 잔액 감소

- 세컨드 로컬 트랜잭션 ( SLT )
  - 실패할 가능성이 없는 것
  - 안전하게 롤백할 수 없어도 된다. (롤백 안해도 된다.)
  - 예/ 물품 추가, 잔액 증가

절차를 보자면
1. 모든 디비에게 FLT 실행
  - 거래 대상이 되는 재산을 가압류 한다.
2. 모든 FLT가 성공하고 나면 SLT를 실행한다.
  - 모든 디비의 재산을 가압류 성공하면 거래를 마저 진행할 수 있다.
3. 만일 FLT가 하나라도 실패하면 전부 롤백한다.
  - 가압류를 풀고 없던일로 한다.


구현의 문제점 1
- 물품의 경우
  - 물품 테이블에 '거래 중' 컬럼을 추가해야 하는지
  - '거래 중' 테이블을 따로 추가 해야하는지?!
- 돈
  - 가압류된 돈의 컬럼을 추가해야하나?

구현의 문제점 2
- 서버가 트랜잭션 하다가 다운된다면, 다른 곳에서 트랜잭션을 이어서 진행행야한다. ( 롤백 또는 SLT를 모두 수행해야 한다 )
- 개별 트랜잭션 마다 복구 코드를 작성해야 한다.

해결 방안
- 롤백할 때 해야 할 일과, SLT할 때 해야할  일을 SQL 쿼리 텍스트로 만들어
- 각 DB의 FLT 시점에 기록한다.

SQL 쿼리 텍스트를 이용 하는 이유
- 어떤 응용에서도 변하지 않는 부분 = 시스템 코드
  - 예/ FLT중 하나라도 실패하면 롤백하는 규칙, 중단된 분산 트랜잭셔녀이 있으면 이어서 실행해주는 코드
- 응용에 따라 변하는 부분 = 로직 코드
  - 예/ 카드 거래, 쿠푠 사용 등등

**시스템 코드와 로직 코드를 분리 해야 하기 때문이다.**

로직 코드는 각각의 디비에 대해서
1. 빼거나 감소해야할 자원을 처리한다 = FLT
2. FLT를 롤백할 때 행야 할 일을 SQL로 기록해 둔다.
  - 넘겨주기로 한 재산을 가압류 하는 컨셉
    - 거래가 취소되면 가압류를 푼다 -> 롤백 쿼리 실행.
    - 거래중에는 내가 함부로 처분 못한다 -> 실제 행을 지웠기 때문에
3. SLt를 해야 할 때 해야 할 일을 SQL 쿼리로 기록해 둔다.
    - 넘겨받아야할 재산을 계약서에 명시하는 컨셉
      - 아직 내 소유인것이 아니다 -> 실제 행이 추가되지 않음.
      - 계약서에 쓰인대로 이행하면 내 재산이 된다.

> 위의 3단계를 로컬 트랜잭션으로 묶어서 실행한다.


시스템 코드 / 실행
1. GET_LOCK("dt_lock" + dt_id)
2. 각각의 디비에 로직 코드를 호출해서 FLT를 실행한다
  - 하나라도 실패하면, 모든 디비에 롤백을 실행한다.
  - FLT가 모두 성공하면, 모든 디비에 SLT를 실행한다.
3. RELEASE_LOCK("dt_lock"+ dt_id)

> 매 단계마다 현재 dt_id, 진행상태, 참여 디비를 기록한다 -> dt_catalog 테이블에

시스템 코드 / 복구
1. 끝나지 않은 분산 트랜잭션이 있는지 dt_catalog를 계속 감시한다 (진행하던 서버가 오류로 죽어버린 상항을 위해)
2. 있으면 GET_LOCK을 시도
  - 성공하면 이어서 마루리 ( 롤백 또는 SLT를 모두 실행)
  - 실패하면 그냥 넘어간다.




- 요약
  - 로컬 트랜잭션을 사용하여 애플리케이션 레벨 분산 트랜잭션 구현
  - FLT / 재산을 압류해서 SQL 텍스트로 바꿈
  - FLT가 하나라도 실패되면 롤백한다
  - 모든 참여 디비에 FLT가 성공하고 나면 SLT를 실행하여 재산을 재부여 한다.


### TCC (Try-Confirm/Cancel)
---

내일 추가해야지









---

>### 참고
> http://mommoo.tistory.com/62 [개발자로 홀로 서기]
>
> https://d2.naver.com/helloworld/407507 [DBMS는 어떻게 트랜잭션을 관리할까?]
>
> https://www.slideshare.net/devcatpublications/ndc2015-74962390 [이승재, 마비노기 듀얼: 분산 데이터베이스 트랜잭션 설계와 구현, NDC2015]
