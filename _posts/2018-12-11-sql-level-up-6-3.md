---
layout: post
title: "SQL 레벨업 - 6장 결합 (3/3)"
comments: true
description: ""
keywords: ""
---



## 20강 결합이 느리다면



### 1. 상황에 따른 최적의 결합 알고리즘

| 이름         | 장점                                                         | 단점                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Nested Loops | 1. (작은 구동테이블 + 내부 테이블의 인덱스) 라는 조건이 충족된다면 빠르다. <br />2. 메모리 또는 디스크 소비가 적으므로 OLTP에 적합<br />3. 비등가 결합에서도 사용 가능 | 1. 대규모 테이블들의 결합에는 부적합<br />2. 내부 테이블의 인덱스가 사용되지 않거나, 내부 테이블의 선택률이 높으면 느리다. |
| Hash         | 1. 대규모 테이블들을 결합할 때 적합                          | 1. 메모리 소비량이 큰 OLTP에 부적합<br />2. 메모리 부족이 일어나면 TEMP 탈락 발생<br />3. 등가 결합에서만 사용 가능 |
| Sort Merge   | 1. 대규모 테이블들을 결합할 때 적합<br />2. 비등가 결합에서도 사용 가능 | 1. 메모리 소비량이 큰 OLTP에 부적합<br />2. 메모리 부족이 일어나면 TEMP 탈락 발생<br />3. 데이터가 정렬되어 있지 않다면 비효율적 |



#### 요약

- 소규모 - 소규모

뭘 사용해도 성능 차이가 크게 없다.



- 소규모 - 대규모

소규모 테이블을 구동 테이블로 하는 Nested Loops를 사용한다. 대규모 테이블의 결합키에 인덱스를 꼭 만든다. 결합 대상 레코드가 많다면 Hash를 사용하는것을 검토할것



- 대규모 - 대규모

일단은 Hash를 사용 하낟. 결합 키로 처음부터 정렬되어 있는 상태라면 Sort Merge를 사용한다.



### 2. 실행 계획 제어

힌트 구문과 매개변수를 사용해 실행 계획을 사용자가 제어할 때는 리스크가 따른다. 데이터양과 카디널리티는 데이터베이스를 운용하면서 계속 바뀌기 때문에, 어떤 시점에는 적절했던 실행 계획이 다른 시점에서는 그렇지 않을 수 있다.



