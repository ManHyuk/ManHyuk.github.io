---
layout: post
title: "SQL 레벨업 - 7장 서브쿼리 (1/2)"
comments: true
description: ""
keywords: ""
---


## 21강. 서브쿼리가 일으키는 폐해


### 1. 서브쿼리의 문제점
서브쿼리의 성능적 문제는 실체적인 데이터를 저장하고 있지 않다는 점이다.
따라서 다음과 같은 문제가 발생한다.

- 연산 비용 추가

실체적인 데이터를 저장하고 있지 않기 때문에 서브쿼리에 접근할 때 마다 SELECT 구문을 실행해서 데이터를 만들어야 한다는 뜻이다. 즉, SELECT 구문 실행에 발생하는 비용이 추가되며 복잡할수록 실행비용이 더 높아진다.

- 데이터 I/O 비용 발생

연산 결과는 어딘가에 저장하기 위해 써두어야 한다. 메모리 용량이 충분하다면 이러한 오버헤드가 적지만, 데이터양이 큰 경우에는 DBMS가 저장소에 있는 파일에 결과를 쓸 때도 있다. (일종의 TEMP 탈락)

- 최적화를 받을 수 없다

서브쿼리로 만들어지는 데이터는 구조적으로 테이블과 차이가 없다.
그러나 명시적 제약, 인덱스가 작성되어 있는 테이블과 달리 서브쿼리에는 메타 정보가 하나도 존재하지 않는다. 따라서 옵티마이저가 쿼리를 해석하기 위해 필요한 정보가 없다.


### 2. 서브쿼리 의존증

고객의 구입 명세 정보를 저장하는 테이블(Receipts)에 순번(Seq 또는 AI idx) 필드는 오래전에 구입했을수록 낮은 값을 가진다.

이때 고객별 최소 순번을 구하는 상황을 가정 하자.

처음 직면하는 문제점은 최소 순번이 고객마다 다르다는 것이다.

```
user_id | seq | price
--------*-----*------
A       |   1|    500
B       |   5|    100
C       |  10|    600
```

> 구하고자 하는 답

만약 구하고자 하는 최소값이 1이라는 보장이 있다면 seq = 1 조건을 통해 답을 도출할 수 있다. 하지만 없으므로 동적으로 구해야 한다.


#### - 서브쿼리를 사용한 방법

간단하게 고개들의 최소 순번 값을 저장하는 서브쿼리(R2)를 만들고, 기존의 Receipts 테이블과 결합하는 방법이 있다.

 ```sql
 SELECT R1.user_id, seq, R1.price
    FROM Receipts R1
        INNER JOIN
            (SELECT user_id, MIN(seq) AS min_seq
                FROM Receipts
                GROUP BY user_id) R2
        ON R1.user_id = R2.user_id
        AND R1.seq = R2.min_seq;
 ```

 이 방법은 간단하지만 두 가지의 단점을 가지고 있다.
 1. 코드가 복잡해서 읽기 어렵다.
 2. 성능이 떨어진다.
    - 서브쿼리는 대부분 일시적인 영역(메모리 또는 디스크)에 확보 되므로 오버헤드가 생긴다.
    - 서브쿼리는 인덱스 또는 제약 정보가 없기 때문에 최적화 되지 못한다.
    - 이 쿼리는 결합을 필요로 하기 때문에 비용이 높고 실행 계획 변동 리스크가 발생한다.
    - Receipts 테이블에 스캔이 두 번 발생한다.



#### - 상관 서브쿼리는 답이 될 수 없다

```sql
SELECT user_id, seq, price
    FROM Receipts R1
WHERE seq = (SELECT MIN(seq)
                FROM Receipts R2
            WHERE R1.user_id = R2.userId);
```

> 상관 서브쿼리를 이용한 방법


상관 서브쿼리를 사용하더라도 Receipts 테이블에 두 번 접근하게 된다.

