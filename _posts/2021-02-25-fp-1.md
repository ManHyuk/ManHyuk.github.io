---
layout: post
title: "함수형 프로그래밍 - 순한맛"
comments: true
description: ""
keywords: ""
published: false
---


# 함수형 프로그래밍 - 순한맛



## index

- 순한맛
    - 함수형 프로그래밍이란?
- 보통맛
    - 지연 연산, 커링, 병렬성, 비동기
- 매운맛
    - Functor, Monad...





## What is Functional Programming

1. a programming paradigm
2. a coding style
3. a mindset

## Why Functional ?

1. More easy (what is prototype, this)
2. safer, easier to debug / maintain



## Again What is FP

- 고차 함수
- 일급 함수
- 커링
- 재귀
- 멱등성
- 순수 함수와 참조 투명성
- 불변성과 영속적 자료구조



## How...?

### Do everything with function

input -> output

```js
// Not functional
const name = "manhyuk";
const greeting = "Hi, I'm ";
console.log(gretting + name);
```



Input , output 개념으로 표현하지 않았기 때문에 functional하지 않다



```js
// Functional
function greet(name) {
  return "Hi I'm " + name;
}
greet("manhyuk");
```

input, output 으로 표현



### Avoid side effect

순수함수란 기본적으로 함수가 input만을 받아 output을 계산하는 함수를 뜻 한다.

```js
// Not pure
const name = "manhyuk";
function greet() {
  console.log("Hi I'm " + name)
}
```

`name` 변수를 input으로 받지 않고 전역 변수에서 읽어왔고 output 또한 없다



```js
// pure
function greet(name) {
  return "Hi I'm " + name;
}
```

output에 영향을 주는것은 input 뿐이다





## High Order Function

함수를 input으로 받거나 output으로 함수를 리턴하는 함

```js
function makeAdjectifier(adjective) {
    return function (string) {
        return adjective + 'cool' + string;
    }
}

const coolifier = makeAdjectifier('cool');
coolifier('conference') // cool conference
```

`map, filter, reduce` 또한 고차함수의 일종이다


## Immutable

```js
const rooms = [1, 2, 3];
rooms[2] = 4;
console.log(rooms); // 1, 2, 4
```

이 코드는 rooms를 임의로 변경하기 때문에 rooms를 사용하는 다른곳에선 문제가 생길 수 있다.

```js
const rooms = [1, 2, 3]
const newRooms = rooms.map(room => {
    if (room === 3) {
        return 4;
    } else {
        return room;
    }
})
console.log(newRooms) // 1, 2, 4
```

rooms를 복사하여 새로운 newRooms라는 변수에 값을 변경했기 때문에

`rooms`를 사용하고 있는 다른 코드에서는 문제가 생기지 않게된다.


하지만 이 코드는 배열이 커지게 된다면 더 오래걸리고 더 메모리를 많이 차지하게 된다.

이를 해결하기 위해 `Persistane Data Structure` 를 사용하면 된다.

기존의 배열을 복사하기 위해 새 배열을 만드는것이 아니라

기존 배열의 요소들을 트리로 만든뒤 새로운 요소만 트리에 합쳐주면 된다. (structure sharing)

이러한 귀찮고 복잡한 과정을 `immuatable.js`를 통해 쉽게 구현이 가능하다.







