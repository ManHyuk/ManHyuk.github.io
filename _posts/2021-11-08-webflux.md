---
layout: post
title: "Spring Webflux 찍먹해보기"
comments: false
description: ""
keywords: ""
---


### Reactive Programming의 배경

리액티브 프로그래밍이 나오게된 배경으로는 크게 두가지 문제를 해결하기 위함이다.

![service-mesh](/images/webflux/w1.png)

쉽게 표현하자면 이렇게 표현할 수 있다.

1. 멍 때리는 시간이 많다. (-> 시간을 줄일 수 있게)
2. 물어봐야만 알 수 있다. (-> 안물어봐도 알 수 있게)



첫 번째 문제부터 이야기해보자면, 리액티브 프로그래밍이 나오기전 일반적인 프로그래밍 방식으로는

하나의 요청이 왔을때 요청을 받은 스레드는 응답할때까지 다른 요청을 받지 못하게 된다.

응답할때 까지 다른 요청을 받지 못하는 상황을 쉽게 `멍` 때린다라고 표현하겠다.


스레드가 멍때리고 있는동안은 다른 요청을 받지 못하게 되는데, 이러한 내용은 `C10K` 에서 여러 해결방안이 나왔다.

일반적으로는 이런 상황을 해결하기 위해서 새로운 스레드를 할당해서 새로운 요청을 받게 한다.

하지만 일반적으로 tomcat의 스레드풀에 스레드는 약 200개가 세팅되는데 동시에 약 200개의 요청이 들어온다면 결과를 보장할 수 없게 된다.

또한 스레드를 무한정 늘리기는 불가능하고 컨텍스트 스위칭 비용이 상당하다.




두 번째 문제는 클라이언트에서 서버에 무언가를 질의해야만 클라이언트에 응답을 할 수 있다는 것이다.

클라이언트-서버 구조에서는 클라이언트에서 요청을 해야만 서버가 응답할 수 있는데, 이 구조에서 문제는 

서버에 리소스가 부족할때 요청이 와도 응답을 해야하고, 반대로 리소스가 넉넉할때 요청이 오지 않으면 응답할 수 없다는 문제를 갖고있다.

![service-mesh](/images/webflux/w2.png)

위 두 문제를 해결하기위해 리액티브 프로그래밍은 두 가지 해결책을 제시했다.

첫 번째 문제인 멍 때리는 시간은 이벤트 루프를 도입해 해결하고자 했고, 

두 번째 문제는 응답을 유지하는 Stream을 도입하여 지속적인 응답을 하여 해결 했다.


![service-mesh](/images/webflux/w3.png)

그리고 이 두 해결책을 Spring에 적용한게 Spring Webflux 이다.


다시말해 Spring Webflux는 Reactive Streams 라는 라이브러리를 기반으로한 구현체라고 볼 수 있다.

